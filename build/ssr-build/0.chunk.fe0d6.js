exports.ids = [0];
exports.modules = {

/***/ "EzjF":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var recursion = "There are a lot of alien words for us non-Computer Science graduates out there. If you are like me, chances are you were intimidated by how mouthful they are. In this blog post, we\u2019ll cover Recursion, and strip that f*cker to it\u2019s simplest form.\n\n_Note that you can find the sources utilized in this blog post at the bottom of the page. It\u2019s always better to have unfiltered information, so go check them out too if you like._\n\nRecursion, what the f*ck is that even mean? Is this English? It is basically a function, calling itself. Kind of like a loop\u200A\u2014\u200Avery much like a loop. Well, I never can fully grasp something before I see it:\n\nTa-da:\n\n```javascript\nfunction factorial(num) {\n if (num < 2) return 1\n return num * factorial(num\u200A\u2014\u200A1)\n};\nfactorial(5);\n```\n\nI never liked math that much back in high school. Turns out, I still don\u2019t, and I have no idea when would you want to use a factorial in JS. Anyway, let\u2019s go through this code together to understand what it does.\n\nFirst, we call the function with a number as an argument (factorial(5)). With this call, we start, what is called a \u201CCall Stack\u201D-\u2026\n\n> \u201CWOWOWOW, DUDE I CAME HERE TO LEARN ABOUT RECURSION, WHAT THE FUCK IS A CALL STACK???\u201D\n> _\u2014\u200Ame._\n\nWell, you probably already know what a Call Stack is, even if you have never heard of it. [MDN explains it really good here.](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack) Let\u2019s say you have to functions: greeting() and sayHi().\n\n```javascript\nfunction greeting() {\n return sayHi();\n}\nfunction sayHi() {\n return \u201CHi!\u201D;\n}\ngreeting()\n```\n\nWhen you invoke the greeting function, It will be pushed to a stack behind the scenes.\n\n> [ greeting ]\n\nThen this greeting function is going to run through and hit another function, and it\u2019s going to call that function, which will be put on to the stack.\n\n> [ sayHi ]\n>\n> [ greeting ]\n\nFor greeting to resolve and return something, it first has the wait for the sayHi function to resolve. So Call Stack has the golden rule of \u201CFirst in, Last out\u201D, like any other stack. Basically, it means when there are no more function calls, it\u2019s going to start to resolve them at the top of the stack, meaning, the last one. Hopefully, I draw a picture of Call Stack in your mind. If not, I\u2019ll leave links to great resources at the end of this topic.\n\n> \u201CYou\u2019ve wasted my time with something I already know, thanks. What the f*ck am supposed to do with this knowledge???\u201D\n> _-again, me?_\n\n_Now, where were we?_ Yes: First, we call the function with a number as an argument (factorial(5)). With this call, we start, what is called a \u201CCall Stack\u201D.\n\nThe second line is the most important part of the recursion. We check whether the given number is less than 2 or not, thus preventing our loop going crazy on us and calling itself infinitely thus crashing our browser.\n\n> **TAKEAWAY: Always have a conditional to break out of the loop.**\n\nIf the given number is less then 2, the function will immediately return 1. Else it will continue and return the result of this operation: \u201Cnum * factorial(num\u200A\u2014\u200A1)\u201D\n\nThis might seem confusing at first, so let\u2019s go through our call stack with factorial(5).\n\n> [ factorial(5) ] \u2192 Calls \u201Cfactorial(4)\u201D\n>\n> [ factorial(4) ] \u2192 Calls \u201Cfactorial(3)\u201D\n>\n> [ factorial(3) ] \u2192 Calls \u201Cfactorial(2)\u201D\n>\n> [ factorial(2) ] \u2192 Calls \u201Cfactorial(1)\u201D\n>\n> [ factorial(1) ] \u2192 Returns \u201C1\u201D\n\n---\n\n> [ factorial(1) ] \u2192 Fifth Call: Since it\u2019s less than 2, it resolves itself and pops out of the stack, returning 1.\n>\n> [ factorial(2) ] \u2192 Forth Call: With the resolved \u201Cfactorial(num\u200A\u2014\u200A1)\u201D call, now the \u201Cnum - factorial(num\u200A\u2014\u200A1)\u201D operation is equal to \u201C2 - 1\u201D, thus resolving and returning 2.\n>\n> [ factorial(3) ] \u2192 Third Call: Same thing with this too, \u201Cnum - factorial(num\u200A\u2014\u200A1)\u201D : \u201C3 - 2 = 6\u201D\n>\n> [ factorial(4) ] \u2192 Second Call => 4 - 6 = 24\n>\n> [ factorial(5) ] \u2192 First Call will yield the result of 5 - 24, which is 120.\n>\n> _see live here: [https://codepen.io/ogunb/pen/jQbGrv](CodePen/ogunb))_\n\n> **TAKEAWAY: Recursions depend on the return statements. You should return something from the functions, otherwise, it\u2019s pointless.**\n\nYou\u2019re probably saying: \u201CEverything you\u2019ve said, I could do with basic loops.\u201D Exactly. Recursion is basically a loop. The important thing here, sometimes loops can be confusing to look at and read, and sometimes it can be easier and more readable to write it with recursion. Also recursion is very powerful with _\u201CLexical Scope\u201D_ Whatever is more readable and easier to implement, choose that. Your future-self and your code maintainers will thank you.";

/* harmony default export */ __webpack_exports__["default"] = (recursion);

/***/ })

};;
//# sourceMappingURL=0.chunk.fe0d6.js.map